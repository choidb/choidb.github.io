---
title: 'Hash Table'
use_math: true
categories:
  - dsai
---

## 1. 해시테이블
* 해시는 딕셔너리 코드와 관련되어 활용되는 개념
* 해싱의 목적은 검색이다.(검색알고리즘의 역할도함)
  * 해싱의 장점: 데이터량에 영향을 덜 받고 성능이 빠름
* 파이썬의 딕셔너리는 내부적으로 해시테이블 구조로 구현되어있음
  * 해시테이블은 검색을 위한 역할과, 딕셔너리를 위한 자료구조의 역할도 함
* 해시 함수, 해시테이블, 해시 충돌, 해시 활용시 성능
  * 해시는 해시함수를 통해 나온 값
  * 해시테이블은 키를 빠르게 저장 및 검색할 수 있는 테이블형태의 자료구조
  * 해시함수는 여러 키를 분할하기 위해 키를 해시값(정수값)으로 매칭시키는 역할을 함
  * 해싱은 쉽게말해 다 흩뜨려놓고 키와 매칭되는 값을 검색하는 과정임

```python
# case 1 - 딕셔너리로 활용되는 해시테이블을 확인할 수 있다.

test_code = {2.5: 'A' ,'2.0': 'B', '1.0': 'C'}
print(test_code[2.5]) 
print(test_code['1.0'])
print(test_code['2.0'])
```
    > A
    > C
    > B

```python
# case 2 - 리스트와 튜플을 활용해서 해시테이블을 확인한다.
# 데이터는 튜플로 저장된다.

test_code = [(2.5, 'A'), ('2.0', 'B'), ('1.0', 'C')]
 
def insert(item_list, key, value):
    item_list.append((key, value))
 
def search(item_list, key):
    for item in item_list:    # 데이터를 검색하려면 딕셔너리보다 오래 걸린다.(키,값 쌍이 없어서 개별 값으로 반복해서 검색하기 때문이다.)
        if item[0] == key:
            return item[1]      
    print('not matching')       
    
print(search(test_code, '2.0'))
print(search(test_code, 2.5))
search(test_code, '2.5')  
```
    > B
    > A
    > not matching

* 해시테이블에 대한 간단한 예시

  * 아래와 같이 키(aqua)와 값(#00FFFF)이 정렬되지 않은 형태로 있는 경우, 색상에 해당하는 코드를 찾는 상황을 생각해보자.

    * 이러한 경우, 반복문과 조건문을 활용한다면 선형시간 성능(O(n))을 나타낸다.

    * 색상이 알파벳순서대로 이미 정렬되어있다면 이진검색을 할 수 있을 것이고, 성능은 로그를 따른다. (O(log n))

```python
# 수도코드

[("aqua", "#00FFFF"), ("beige", "#F5F5DC"), ("chartreuse", "#7FFF00")]

for i in range(0, len(dictionary)):
  1)알파벳순서대로 정렬되어있음
  2)알파벳찾기(예를 들어, "beige"를 찾아보겠다.)
  3)이진검색 알고리즘 활용
  4)로그시간 성능이 나온다.
```

* 파이썬의 딕셔너리는 자료구조의 해시테이블로 구현되어 있으므로, 딕셔너리를 활용하여 해시테이블 개념을 이해하자

```python
# 먼저 값이 없는 딕셔너리를 선언한다.
dict = {}

# 값추가
dict['a'] = 1
dict['b'] = 2
dict['c'] = 3
dict
```
* 위의 결과값은 {'키': 값} 쌍을 나타낸다.

* 해시테이블 dict의 값을 읽어오는데 사용되는 문자열이 "키"다.

* 해시테이블에 저장된 데이터(값)에 접근하려면 키를 알아야한다.
  
```python
# 아래와 같이 키를 통해 값을 알 수 있다.
dict['c']
```
```python
# 해시테이블에 반복문을 적용시켜보자.

for key in dict.keys():
  print(dict[key])

# (키,값) 쌍을 출력해본다.

for key, value in dict.items():
  print('(키',key,',','값',value,')')
```
## 2. 해시함수
* 해시함수는 키를 해시테이블 내의 버킷(=hashes=해시값)으로 매핑시킨다.

* 해시함수 : 입력값의 형태는 다양하고, 출력값의 형태는 숫자이다.

* 해시함수 요구조건 :

  * 해시함수는 입력값이 같다면, 동일한 출력값을 받아야 한다.

  * 입출력값이 일정하지 않다면 적절한 해시함수가 아니다.

    * 예를 들어, 입력값 'aqua'가 4를 반환한다면, 입력값 'beige'는 4를 반환할 수 없다.

    * 해시함수는 특정 범위 안에 있는 숫자를 반환해야 한다.

* 하나의 해시함수가 입력 데이터별로 다른 숫자와 매핑된다면, 그것은 완벽한 해시함수이다.

  * 해시함수가 입력데이터에 따라 다른 숫자를 반환하게 되면 해시충돌을 최소화하는 것이다.

### 1) 기본 해시함수

* 해시함수는 보통 문자열 입력값에 정수형 출력값을 반환한다.

* 정수형에서 문자열로 변환하기위해서, 해시함수는 문자열에 해당하는 개별적인 단어를 활용한다.

  * 아래 예시는 파이썬에서 .encode() 메소드를 활용해서 문자열에서 바이트 코드로 인코드하는 것이다.

  * 인코딩된 후에, 정수형은 각 단어를 나타낸다.

```python
# 인코딩 예제
bytes_representation = "hello".encode()

for byte in bytes_representation:
    print(byte)
```
    > 104
    > 101
    > 108
    > 108
    > 111

* 여러개의 정수들을 하나의 문자열로 변환해보자.

* 정수값의 합을 반환하는 방법을 활용한다.

```python
# 정수값의 합 반환
bytes_representation = "hello".encode()

sum = 0
for byte in bytes_representation:
    sum += byte

print(sum)
```
    > 532

```python
# 해시함수를 만들고 활용해보자.
def my_hashing_func(str, list_size):
    bytes_representation = str.encode()    
    sum = 0
    for byte in bytes_representation:
        sum += byte

    print('sum:', sum)
    print('list_size', list_size)
    print('sum%list_size:', sum % list_size)
    return sum % list_size
```
* 위의 해시함수를 활용하여 추가학습을 해본다.

  * 먼저 5개의 빈 슬롯이 들어가는 리스트를 초기화시킨다.

```python
my_list = [None] * 5
```
* 리스트에 있는 적합한 인덱스에 색상 이름문자열에 매핑되기 위해 해시함수를 사용해야 한다.

* 인덱스에 헥사코드값을 저장한다.

* 해시함수를 사용하여 값을 검색할 수 있다.

```python
# 위의 my_hashing_func이라는 해시함수를 활용하여 아래처럼 값을 확인할 수 있다.
my_list = [None] * 5

my_list[my_hashing_func("aqua", len(my_list))] = "#00FFFF" # 리스트에 값을 입력

print(my_list[my_hashing_func("aqua", len(my_list))]) # 리스트에 있는 값을 출력

print(my_list)
```
## 3. 해시성능
* O(1) 시간복잡도 안에 검색, 삽입, 삭제를 할 수 있다.

  * 상수 시간(O(1))은 해시테이블의 사이즈에 관계없이 동일한 양의 계산을 다룬다.

    * 해시충돌로 인해 모든 bucket의 value를 찾아야 하는 경우(반복문)도 있다.
* 만약 해시테이블이 하나의 요소를 갖고 있다면, 해시테이블 인덱스 갯수에 관계없이 프로그램 수행시간이 비슷하다.

  * 이유는 해시함수때문이다.

* 검색 / 삽입 / 삭제 무엇을 하든지 해시함수는 키를 통해 저장된 값에 연관된 인덱스를 반환한다.(즉, 키와 인덱스가 매칭되야함)

## 4. 해시충돌
### 1) 해시충돌
* 지금까지, 우리는 해시 함수가 항상 다른 입력을 다른 인덱스에 매핑한다는 가정하에 학습하였다.

  * 그러나 가능한 모든 데이터를 알고 있지 않으면 완벽한 해시 함수를 작성하는 것은 불가능하다.
* 해시충돌은 키가 들어갈 자리(버킷)가 없는 경우에 발생한다.

* 아래와 같이 해시테이블의 충돌에 대한 상황을 쉽게 알 수 있다.

  * 키 B와 C 같은 경우가 해시함수를 통해 계산된 상태에서 버킷4에서 충돌이 발생했다.

  * 충돌이 적은 해시함수를 만드는 것이 해시테이블의 가장 중요한 목적이다.

```python
# 해시테이블의 기본 구조
# 빈 값이 있는 사이즈가 5인 해시테이블을 생성해본다.

hashtable = [None] * 5
print(hashtable)
```
    > [None, None, None, None, None]

```python
# 위의 해시테이블과 연결지어 해시함수를 만들어볼 수 있다.

def hash_function(key):
    return key % len(hashtable)
 
print(hash_function(10)) 
print(hash_function(20)) 
print(hash_function(31)) 

# 해시테이블에 데이터를 삽입해볼 수 있다.

def insert_hash(hashtable, key, value):
    hash_key = hash_function(key)
    hashtable[hash_key] = value 

insert_hash(hashtable, 10, 'A')   # 해시함수로 계산되어 0번째 인덱스에 A가 삽입됨
print(hashtable)
 
insert_hash(hashtable, 23, 'B')   # 3번째 인덱스에 B가 삽입됨
print(hashtable)
```
    > 0
    > 0
    > 1
    > ['A', None, None, None, None]
    > ['A', None, None, 'B', None]

```python
# 위의 예시를 활용해서 충돌이 일어나는 상황을 살펴보자.

# 현재 0번째 인덱스에 A, 3번째 인덱스에 B가 저장되어있다.
# 아래와 같이 해시함수를 통해 계산된 0번째 인덱스에 'Collision' 값을 삽입할 경우, 충돌이 발생한다.
# 그리고 'A'값은 'Collision'으로 대체(충돌)된다.
insert_hash(hashtable, 20, 'Collision')
print(hashtable)
```
    > ['Collision', None, None, 'B', None]

* 충돌상황을 방지하기 위한 방법으로 체이닝과 오픈어드레싱이 있다.

### 2) 충돌 방지 방법 - Chaining(체이닝)
* 장점
  * 한정된 저장소를 효율적으로 사용가능해서 상대적으로 적은 메모리를 사용하는 것
  * 메모리 공간을 미리 잡아놓을 필요가 없음
* 단점
  * 한 해시의 자료들이 연결되면 검색 효율이 낮아질 수 있다.


* 해시 테이블에서 동일한 해시값에 대해 충돌이 일어나면, 그 위치에 있던 버킷에 키값을 뒤이어 연결한다.

* 데이터의 형태는 위 그림처럼 연결리스트의 형태를 갖는다.

  * 해시테이블 방법은 체이닝 방식을 활용한다.

    * 체이닝의 원리

    1) 키의 해시값을 계산한다.

    2) 해시값을 이용해 리스트의 인덱스를 구한다.

    3) 같은 해시값이 있다면(충돌한다면) 리스트로 연결한다.

* 충돌을 줄이기 위해, 각 리스트에 대해 연결(리스트 형태)하도록 한다.

  * 따라서, 특정 해시값에 대해 충돌이 발생해도, 체이닝을 통해 값을 찾을 수 있다.
* 아래 그림과 같이 체이닝으로 충돌상황을 재현하고 해결하는 모습을 구현해볼 수 있다.

  * 체이닝은 연결리스트의 원리를 사용하기 때문에 해시값이 같은 노드를 연결하는 모습을 나타낸다.

  * 아래와 같이 해시값이 인덱스 역할을 한다.(0,1,2,3,...,8)

  * 아래 예시 그림은 나누기방법(division method)을 사용한 것인데, 나누기방법은 쉽기 때문에 많이 사용되는 기본적인 해시함수로서 키값이 정수로 가정된다.

    * 아래 해시함수의 공식은 '키의 값 % 13' 이다.

    * 따라서 매핑되는 해시값(버킷)이 '13으로 나눈 나머지값'을 나타내도록 구성하였다.

    * 해시값 4에서 충돌이 발생되므로 체이닝을 통해 연결시키는 것을 확인할 수 있다.

```python
# 체이닝을 예시코드로 배워보자.
# 아래와 같이 리스트안에 중첩되는 리스트를 만들어서 연결개념으로 해시테이블을 생성한다.

chain_hash_table = [[] for _ in range(10)]  # 이번에는 10의 길이로 테스트를 진행한다.(0~9, 총 10개의 인덱스)
print(chain_hash_table)
```
    > [[], [], [], [], [], [], [], [], [], []]
```python
# 해시함수는 위와 동일하게 테스트할 수 있다.

def chain_hash_func(key):
    return key % len(chain_hash_table)
 
print(chain_hash_func(10)) 
print(chain_hash_func(20)) 
print(chain_hash_func(25)) 
```
    > 0
    > 0
    > 5

```python
# append를 활용해서 키-값 쌍을 해시테이블에 삽입한다.

def chain_insert_func(chain_hash_table, key, value):
    hash_key = chain_hash_func(key)
    chain_hash_table[hash_key].extend(value)
    
chain_insert_func(chain_hash_table, 10, 'A')
print (chain_hash_table)

chain_insert_func(chain_hash_table, 25, 'B')    # 5번째 인덱스에 B가 삽입된다.
print (chain_hash_table)

# 아래 결과값과 같이 중첩되는 결과값이 있더라도 값이 대체(충돌)되는 것이 아니다.
# 리스트 메소드 개념(list.append)이 활용되어 값을 이어 붙인다.('A' -> 'C')
chain_insert_func(chain_hash_table, 20, 'C')    
print (chain_hash_table)
```
    > [['A'], [], [], [], [], [], [], [], [], []]
    > [['A'], [], [], [], [], ['B'], [], [], [], []]
    > [['A', 'C'], [], [], [], [], ['B'], [], [], [], []]

### 3) 충돌 방지 방법 - open addressing(오픈 어드레싱)
* 장점
  * (데이터 한정되어있다는 가정하) 빈공간 없이 테이블을 채워서 사용하므로 낭비되는 공간없이 사용가능
  * 또 다른 저장공간 없이 해시테이블 내에서 데이터 저장 및 처리가 가능
* 단점
  * 해시함수 성능에 따라서 해시 테이블의 성능이 좌지우지된다.
  * 데이터의 크기가 늘어나면 그에 해당하는 저장소를 마련해둔다.

* 리니어 프로빙/선형탐사
* 다른 로직의 함수를 활용하기 때문에 open address이라 한다.

  * 이 방법은 비어있는 배열 슬롯이 발견될 때까지 array의 위치를 검색하여 해시 충돌을 해결한다.

  * 충돌이 일어나는 경우, 탐사(Probing)를 진행하면서 빈 공간을 찾아야 해결이 된다.

    * 체이닝과 다르게 저장공간이 정해져있다.

* 그렇다면 해시테이블로 구현된 파이썬의 자료형은 무엇인가? 딕셔너리이다.

  * 파이썬의 경우 해시테이블 충돌 시 어떤 방식을 통해 해결할까?

  * 체이닝의 경우 연결리스트를 활용하고, 오픈어드레싱은 내부적으로 공간이 어느정도 정해진 배열을 활용하여 설계되어있다.

    * 파이썬의 경우, 내부적으로 오픈어드레싱 방식을 활용한다.
* 파이썬에서 오픈어드레싱을 활용하는 경우 빈 공간이 없는 경우 시간이 오래 걸릴 수 있다.

  * 때문에 로드팩터를 작게 설정하여 성능 저하 문제를 해결한다.

### 4) Load Factor(로드 팩터)
* 적재율: 실제 사용하는 키 개수/테이블의 크기
  * 실제 사용하는 키의 개수(k)
  * 해시테이블의 크기를(N)
  * 적재율은 K/N
* 로드팩터를 수치로해서 테이블 리사이징을 자동적으로 해주는 형태
  * 초기용량 &rArr; 16
  * 로드팩터 0.75 &rArr; 0.75 범위를 벗어나면 테이블 크기를 두배로 늘려준다(리사이징)
    * 16 * 0.75 &rArr; 12 12번째 키값을 저장한 후에 용량을 자동으로 조정
  * 더 낮은 로드팩터 &rArr; 더 적은 충돌가능성 &rArr; 고성능 


* 로드 팩터는 절대적인 성능측정도구가 아닙니다.

  * 로드 팩터에는 해시테이블의 상황, 입출력의 상황, 메모리에 적재되는 시간 등 영향을 주는 요소가 다양합니다.

  * 로드 팩터에서 발생할 수 있는 상대성을 고려하며 개념을 활용하기 보다 이러한 개념이 있다는 것을 인지해주시길 바랍니다.

  * 로드 팩터에 대한 자세한 내용은 README의 레퍼런스에 첨부하였으니 추가학습을 원하시는 분들은 참고하시면 됩니다.

* 위의 공식처럼 로드 팩터 비율에 따라 해시함수 재작성여부, 해시테이블 크기조정여부가 결정된다.

  * 로드 팩터값을 통해 해시 테이블의 성능정도를 파악할 수 있다.
* 해시 테이블에 저장된 항목 수(해시테이블에 입력된 키 갯수)를 슬롯 수(해시 테이블 전체 인덱스 갯수)로 나눈 값이다.

  * 오픈어드레싱을 사용하면 최대 로드 팩터는 1정도 나온다.

  * 체이닝을 사용하면 로드 팩터는 오픈어드레싱보다 좋은 성능(로드팩터 <= 1)을 보일 수 있다.

    * 로드팩터를 낮추면 해시에 대한 성능이 올라간다.

### 5) 해시 테이블에 대한 다양한 실생활 사례
* 전화 번호부 (사람의 이름을 전화 번호에 매핑)

* DNS 확인 (웹 주소를 IP 주소에 매핑)

* 학생 기록 (고유한 학생 ID가 학생 정보에 매핑)

* 도서관 시스템 (책의 고유 식별자가 자세한 책 정보에 매핑)

### 6) 좋은 해시함수란?
* 해시함수를 어떻게 구현하는지에 따라 해시의 성능이 결정된다.

1) 키와 값의 계산과정이 쉬워야 한다.(위에서 설명한 나누기방법처럼 쉬워야 한다.)

2) 충돌을 피할 수 있어야한다.

   * 계산과정이 쉬운 경우

     * 체이닝(연결리스트)이 제대로 활용된다면 반복작업없이 해시의 검색 알고리즘을 활용하여 O(1)의 검색시간을 확보할 수 있을 것이다.

     * 해시값은 해시되는 데이터에 의해 완전히 결정된다.

     * 해시함수는 모든 입력 데이터를 사용해야 한다.

   * 충돌을 피할 수 있는 경우

     * 해시함수는 가능한 해시값의 전체 집합에 데이터를 균일하게 배포한다.

     * 해시함수는 유사한 문자열에 대해 다른 해시값을 생성한다.

   * 해시를 사용할 때 주의할 점

     * 키 데이터타입에 맞는 좋은 해시함수가 있는지 확인

     * 적절한 해시테이블 크기(배열크기)

* 충돌시 테이블 리사이징을 하는데 그때 값을 재계산해서 데이터를 넣어주는가?
  * 해시 테이블 크기 조정은 새 크기에 매핑할 새 해시 함수를 선택하고, 새 크기의 해시 테이블을 만들고, 이전 테이블의 요소를 반복하고, 새 테이블에 삽입하는 작업으로 구성됩니다.
