# 자료구조와 그래프

## 1. 그래프
### 1) 그래프의 기본 컨셉
* 그래프는 정점과 간선으로 이루어진 자료구조로, 연결되어 있는 객체간의 관계를 표현할 수 있는 자료구조이다.
* 그래프를 표현하는 두 가지 방법에는 인접행렬(Adjacency Matrix)과 인접 리스트(Adjacency List)가 있다.
* 노드 간에 연결될 수 있다는 점을 제외하고 트리와 비슷함, 루프를 형성할 수도 있음
* 트리에서는 노드를 탐색할 경우 제한이 있지만, 그래프는 루프형성이 가능하기 때문에 다른 범위의 개념으로 필요한 자료구조임
  * Object간의 관계를 표현할 때 유용함
  * 그래프는 vert(노드 또는 정점)과 edge(간선)으로 연결되어 있음

### 2) 그래프와 트리의 특징
* 그래프는 노드간의 관계, 트리는 노드간의 계층을 표현
* 그래프와 트리는 서로 다른개념
  * 트리에는 그래프에서 없는 계층 개념이 존재

### 3) 그래프의 유형
* 그래프의 특성은 방향성(directed) 또는 undirected(무방향성) 그래프가 있음
* 그래프가 한쪽 방향(one-way)로 설명된다면 directed 그래프가 가장 적합함
* 방향성 그래프는 순서가 있고 마지막 노드(leaf)가 있음(리프노드)
* 양방향 그래프도 존재함(bidirectional)
* 그래프에서 노드연결관계의 목적이 상호 교환이라면, undirected 그래프가 가장 적합
* 교환 관계는 항상 상호이므로 undirected 그래프가 가장 의미있음
  * 상호 교환: 화살표로 연결된 노드들이 서로 노드정보를 공유함
* 무방향성은 방향이 지정x
* 간선으로 연결된 노드들끼리는 서로 인접(adjacent)해있다고 하고, 이웃(neighbor)라 칭함

### 4) Cyclic and Acyclic Graphs(순환 및 비순환 그래프)
* 순환(루프)를 형성할 수 있는 경우 그래프는 순환그래프임
  * undirected 그래프는 항상 동일한 노드에 재방문할 수 있으므로 순환 그래프
* 순환 형성할 수 없는 경우 비순환 그래프

### 5) Weighted Graphs(가중 그래프)
* 가중그래프는 edge(간선)과 관련된 값이 존재
* 각 edge의 가중치에 할당된 특정값을 호출
* 가중치는 서로 다른 그래프에서 서로 다른 데이터를 나타냄
* 그래프에서 경로의 총 가중치가 높을수록 경로이동시간(비용)이 길어짐
  * 가중치는 모든 경로 비교시 어떤 경로를 선택할 지에 사용됨
* 순회는 그래프에 연결된 노드를 탐색함
* 아직 방문하지 않은 노드의 순회 순서가 중요
* 순회개념은 DFS, BFS와 같은 순회 알고리즘과 연관

### 6) Directed Acyclic Graphs(DAGs)
* 방향성 비순환 그래프(DAG)는 순환되지 않고 특정한 단방향 그래프임
* edge가 순서대로 향하도록 DAG의 노드를 선형(단방향)으로 정렬할 수 있음

||그래프|트리|
|-|-|-|

* visualgo.net &rArr; 눈으로 보기 편하게 만들어놓음

## 2. 그래프의 활용
### 1) 그래프의 활용
* 그래프를 나타내는 두 가지 방법은 인접리스트(adjacency lists)과 인접행렬(adjacency matrices)
* 그래프를 구현할 때 저장할 데이터 유형과 그래프에서 실행해야하는 작업을 이해하는 것이 중요
* 각 유형을 사용할 때, verts C와 D 사이의 관계를 어떻게 표현하는지가 중요

### 2) 인접리스트(Adjacency List)
* 인접리스트에서 그래프는 전체 노드 목록을 저장함

```python
# 위 그림에 대해 딕셔너리를 사용한 인접리스트 예시
# 노드가 키가 되고, 인접노드가 값이 되는 딕셔너리이다.
# 가장자리 노드들은 set으로 구현되어 있다.

class Graph:
    def __init__(self):
        self.vertices = {
                            "A": {"B"},   # 여기서 {"B"}가 set의 형태이다.
                            "B": {"C", "D"}, # {"B" : {}}의 형태는 딕셔너리
                            "C": {"E"},     # 즉, 딕셔너리 안에 set이 있는 것이다.
                            "D": {"F", "G"},
                            "E": {"C"},
                            "F": {"C"},
                            "G": {"A", "F"}
                        }
```
* vertices(정점)는 O(1)상수시간에 각 edge(간선)에 접근할 수 있다.

  * edge가 set에 포함되어 있기 때문에 O(1) 상수 시간에 edge가 있는지 확인할 수 있다.

  * 예를 들어, A가 G set에 포함되어있다는 뜻이다.

### 3) 인접행렬(Adjacency Matrix)
* 소스코드로 작성하기 전에, 0과 1로 구성되는 행렬부분(노드간 연결)이 어떤 부분인지 그림으로 그려본다.
  * 행노드와 연결되는 열노드에 대해서 1 값이 된다.

```python
# 리스트로 구현한 인접행렬
# 아래 코드처럼 위의 간선 가중치는 1이다.

class Graph:
    def __init__(self):
        self.edges = [[0,1,0,0,0,0,0],
                      [0,0,1,1,0,0,0],
                      [0,0,0,0,1,0,0],
                      [0,0,0,0,0,1,1],
                      [0,0,1,0,0,0,0],
                      [0,0,1,0,0,0,0],
                      [1,0,0,0,0,1,0]]
```
* 행렬은 리스트 안에 리스트가 있는 2차원 배열로 표현된다.

  * 구현을 통해 기본 제공되는 행렬 간에 edge weights(간선 가중치)를 알 수 있다.

  * 0은 관계가 없음을 나타내지만 다른 값은 edge label 또는 edge weight를 나타낸다.

  * 인접행렬의 단점은 노드 값과 해당 인덱스 사이에 연관성이 없다는 것이다.

* 실제로 인접리스트와 인접행렬을 모두 구현하면 Vertex(정점, node) 및 Edge(간선, link) 클래스를 포함하여 더 많은 정보를 파악할 수 있다.

### 4) 그래프에서의 복잡도
* 인접리스트는 리스트의 개념을 활용하고, 인접행렬은 코드에서 볼 수 있듯이 배열의 개념을 활용
* 인접행렬의 특징(장점)은 구현이 쉽다
  * 인접행렬은 리스트를 활용하여 가중치만을 표현하기 때문
  * 인접리스트는 노드와 가중치를 위한 딕셔너리를 구성해야 되므로 구현이 쉬움
* 인접행렬의 단점
  * 특정 노드에 방문한 노드들을 알기위해 모든 노드를 확인해야함(시간복잡도 O(N))
  * 따라서 인접리스트로 표현방식이 생김
* 인접리스트는 실제 연결된 관계만을 저장해주기 때문에 실행시간에 영향을 적게 줌
  * 인접리스트 단점
  * 특정 노드간의 연결관계를 확인하기 위해 반복문이 활용되야하고 O(N) 이상의 시간복잡도가 될 것임

#### 인접리스트와 인접행렬의 시간복잡도
* 그래프 = (V, E) &rArr; 노드의 개수: n, 엣지의 개수: m
* 메모리
  * 인접행렬: O(n^2)
  * 인접리스트: O(n+m)
* u, v &rArr; u와 v라는 엣지가 존재하는가
  * 인접행렬: if graph[u][v] == 1: &rArr; O(1)
  * 인접리스트: graph[u].search(v) &rArr; 최악의 경우 O(n)
* u에 인접한 모든 노드 y에 대해 특정 액션을 취하라
  * 인접행렬 &rArr; O(n)
    * for v in range(1, n+1):
      * do with G[u][v]
  * 인접리스트
    * for each edge in G[u]
* 새로운 엣지 (u, v) 삽입:
  * 인접행렬: G[u][v] = 1 (1이상의 값), O(1)
  * 인접리스트: &rArr; O(1)
* 기존의 엣지(u, v) 삭제
  * 인접행렬: G[u][v] = 0, O(0)
  * 인접리스트: G[u].search[v] &rArr; remove &rArr; 최악의 경우 O(n)

**인접리스트 구현**
  * 위의 코드와 차이: edge(간선)에 가중치(weight)를 부여 할 수 있다는 것

```python
# 인접리스트 구현

class Graph:
    def __init__(self):
        self.vertices = {
                            "A": {"B": 1},  # 가중치 부여
                            "B": {"C": 3, "D": 2},  # 가중치 부여
                            "C": {},
                            "D": {},
                            "E": {"D": 1}   # 가중치 부여
                        }
```
**인접행렬 구현**

행렬의 한 가지 이점은 간선 가중치를 표현하는 것이 쉽다.
```python
# 인접행렬 구현

class Graph:
    def __init__(self):
        self.edges = [[0,1,0,0,0],
                      [0,0,3,2,0],
                      [0,0,0,0,0],
                      [0,0,0,0,0],
                      [0,0,0,1,0]]
```

## 3. 순회(Traversal)
### 1) 순회 기본개념
* 순회는 Traversal로 명명되며, 그래프 또는 트리처럼 연결된 구조에서 노드를 한 번씩 탐색하는 개념
* 순회의 목적은 모든 노드 또는 특정 노드를 방문하는 방법을 찾는 것
* BST(이진검색트리)와 다른 규칙이 적용되며 방향에 따라 탐색방법이 달라질 수 있다.

### 2) 그래프와 트리의 순회구분
* 그래프의 순회는 DFS(깊이우선탐색), BFS(너비우선탐색) 방법이 있다.

  * DFS, BFS는 탐색 알고리즘이다
* 트리의 순회는 전위, 중위, 후위순회이다.
* 그래프는 루트, 부모, 자식노드 개념이 없지만 전위, 중위, 후위순회의 순회개념을 활용하여 DFS, BFS를 구현할 수 있다.
  * 전위순회(preorder traverse) : 루트를 먼저 방문

  * 중위순회(inorder traverse) : 왼쪽 서브트리를 방문 후 루트방문

  * 후위순회(postorder traverse) : 순서대로 서브트리(왼쪽->오른쪽)를 모두 방문 후 루트를 방문

**트리순회 코드**
루트는 1개(10)이다.
부모노드는 트리별 1개씩이니 총 4개이다.(8, 1, 9, 12)

```python
# 수도코드로 배우는 트리순회

# 먼저 순회를 진행하기 위해 트리형태의 노드들을 생성한다.
class node:

  # root -> left -> right 방향대로 노드 생성
  def __init__(self, value, left=None, right=None): 
    value  
    left    
    right  

root_node = node(10,
                 node(8, 
                      node(7),  
                      node(1, 
                           node(3), node(2)
                           )
                      ),
                 node(9, 
                      node(11), 
                      node(12, 
                           node(13)
                           )
                      )
                 )
```
```python
# 전위 순회 
def pre_order(node):

  print(node.value)       # 루트노드
  pre_order(node.left)    # 왼쪽노드
  pre_order(node.right)   # 오른쪽노드
```
```python
# 중위 순회
def in_order(node):

  in_order(node.left)    # 왼쪽노드
  print(node.value)      # 루트노드
  in_order(node.right)   # 오른쪽노드
```
```python
# 후위 순회
def post_order(node):

  post_order(node.left)   # 왼쪽노드
  post_order(node.right)  # 오른쪽노드
  print(node.value)       # 루트노드
```
